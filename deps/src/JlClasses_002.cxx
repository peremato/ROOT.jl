// this file was auto-generated by wrapit v1.3.3-dirty
#include "Wrapper.h"

#include "jlROOT.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<TObjArray> : std::false_type { };
  template<> struct DefaultConstructible<TObjArray> : std::false_type { };
template<> struct SuperType<TObjArray> { typedef TSeqCollection type; };
}

// Class generating the wrapper for type TObjArray
// signature to use in the veto file: TObjArray
struct JlTObjArray: public Wrapper {

  JlTObjArray(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TObjArray (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TObjArray.h:31:7
    jlcxx::TypeWrapper<TObjArray>  t = jlModule.add_type<TObjArray>("TObjArray",
      jlcxx::julia_base_type<TSeqCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TObjArray>>(new jlcxx::TypeWrapper<TObjArray>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TObjArray>> type_;
};
std::shared_ptr<Wrapper> newJlTObjArray(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTObjArray(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TTimer> : std::false_type { };
  template<> struct DefaultConstructible<TTimer> : std::false_type { };
}

// Class generating the wrapper for type TTimer
// signature to use in the veto file: TTimer
struct JlTTimer: public Wrapper {

  JlTTimer(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TTimer (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TTimer.h:51:7
    jlcxx::TypeWrapper<TTimer>  t = jlModule.add_type<TTimer>("TTimer");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TTimer>>(new jlcxx::TypeWrapper<TTimer>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TTimer>> type_;
};
std::shared_ptr<Wrapper> newJlTTimer(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTTimer(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TDictionary> : std::false_type { };
  template<> struct DefaultConstructible<TDictionary> : std::false_type { };
template<> struct SuperType<TDictionary> { typedef TNamed type; };
}

// Class generating the wrapper for type TDictionary
// signature to use in the veto file: TDictionary
struct JlTDictionary: public Wrapper {

  JlTDictionary(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TDictionary (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:167:7
    jlcxx::TypeWrapper<TDictionary>  t = jlModule.add_type<TDictionary>("TDictionary",
      jlcxx::julia_base_type<TNamed>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TDictionary>>(new jlcxx::TypeWrapper<TDictionary>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;



    DEBUG_MSG("Adding wrapper for TDictionary & TDictionary::operator=(const TDictionary &) (" __HERE__ ")");
    // signature to use in the veto list: TDictionary & TDictionary::operator=(const TDictionary &)
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:182:17
    t.method("assign", static_cast<TDictionary & (TDictionary::*)(const TDictionary &) >(&TDictionary::operator=));

    DEBUG_MSG("Adding wrapper for void TDictionary::CreateAttributeMap() (" __HERE__ ")");
    // signature to use in the veto list: void TDictionary::CreateAttributeMap()
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:184:24
    t.method("CreateAttributeMap", static_cast<void (TDictionary::*)() >(&TDictionary::CreateAttributeMap));

    DEBUG_MSG("Adding wrapper for Long_t TDictionary::Property() (" __HERE__ ")");
    // signature to use in the veto list: Long_t TDictionary::Property()
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:192:24
    t.method("Property", static_cast<Long_t (TDictionary::*)()  const>(&TDictionary::Property));

    DEBUG_MSG("Adding wrapper for TDictionary * TDictionary::GetDictionary(const char *) (" __HERE__ ")");
    // signature to use in the veto list: TDictionary * TDictionary::GetDictionary(const char *)
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:193:24
    module_.method("TDictionary!GetDictionary", static_cast<TDictionary * (*)(const char *) >(&TDictionary::GetDictionary));

    DEBUG_MSG("Adding wrapper for TDictionary * TDictionary::GetDictionary(const std::type_info &) (" __HERE__ ")");
    // signature to use in the veto list: TDictionary * TDictionary::GetDictionary(const std::type_info &)
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:194:24
    module_.method("TDictionary!GetDictionary", static_cast<TDictionary * (*)(const std::type_info &) >(&TDictionary::GetDictionary));

    DEBUG_MSG("Adding wrapper for bool TDictionary::WantsRegularMembers(TDictionary::EMemberSelection) (" __HERE__ ")");
    // signature to use in the veto list: bool TDictionary::WantsRegularMembers(TDictionary::EMemberSelection)
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:220:16
    module_.method("TDictionary!WantsRegularMembers", static_cast<bool (*)(TDictionary::EMemberSelection) >(&TDictionary::WantsRegularMembers));

    DEBUG_MSG("Adding wrapper for bool TDictionary::WantsUsingDecls(TDictionary::EMemberSelection) (" __HERE__ ")");
    // signature to use in the veto list: bool TDictionary::WantsUsingDecls(TDictionary::EMemberSelection)
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:221:16
    module_.method("TDictionary!WantsUsingDecls", static_cast<bool (*)(TDictionary::EMemberSelection) >(&TDictionary::WantsUsingDecls));

    DEBUG_MSG("Adding wrapper for Version_t TDictionary::Class_Version() (" __HERE__ ")");
    // signature to use in the veto list: Version_t TDictionary::Class_Version()
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:224:4
    module_.method("TDictionary!Class_Version", static_cast<Version_t (*)() >(&TDictionary::Class_Version));

    DEBUG_MSG("Adding wrapper for TClass * TDictionary::IsA() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TDictionary::IsA()
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:224:4
    t.method("IsA", static_cast<TClass * (TDictionary::*)()  const>(&TDictionary::IsA));

    DEBUG_MSG("Adding wrapper for void TDictionary::StreamerNVirtual(TBuffer &) (" __HERE__ ")");
    // signature to use in the veto list: void TDictionary::StreamerNVirtual(TBuffer &)
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:224:4
    t.method("StreamerNVirtual", static_cast<void (TDictionary::*)(TBuffer &) >(&TDictionary::StreamerNVirtual));

    DEBUG_MSG("Adding wrapper for const char * TDictionary::DeclFileName() (" __HERE__ ")");
    // signature to use in the veto list: const char * TDictionary::DeclFileName()
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:224:4
    module_.method("TDictionary!DeclFileName", []() { return (std::string)TDictionary::DeclFileName(); });

    DEBUG_MSG("Adding wrapper for int TDictionary::ImplFileLine() (" __HERE__ ")");
    // signature to use in the veto list: int TDictionary::ImplFileLine()
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:224:4
    module_.method("TDictionary!ImplFileLine", static_cast<int (*)() >(&TDictionary::ImplFileLine));

    DEBUG_MSG("Adding wrapper for const char * TDictionary::ImplFileName() (" __HERE__ ")");
    // signature to use in the veto list: const char * TDictionary::ImplFileName()
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:224:4
    module_.method("TDictionary!ImplFileName", []() { return (std::string)TDictionary::ImplFileName(); });

    DEBUG_MSG("Adding wrapper for const char * TDictionary::Class_Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * TDictionary::Class_Name()
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:224:4
    module_.method("TDictionary!Class_Name", []() { return (std::string)TDictionary::Class_Name(); });

    DEBUG_MSG("Adding wrapper for TClass * TDictionary::Dictionary() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TDictionary::Dictionary()
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:224:4
    module_.method("TDictionary!Dictionary", static_cast<TClass * (*)() >(&TDictionary::Dictionary));

    DEBUG_MSG("Adding wrapper for TClass * TDictionary::Class() (" __HERE__ ")");
    // signature to use in the veto list: TClass * TDictionary::Class()
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:224:4
    module_.method("TDictionary!Class", static_cast<TClass * (*)() >(&TDictionary::Class));

    DEBUG_MSG("Adding wrapper for void TDictionary::Streamer(TBuffer &) (" __HERE__ ")");
    // signature to use in the veto list: void TDictionary::Streamer(TBuffer &)
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:224:4
    t.method("Streamer", static_cast<void (TDictionary::*)(TBuffer &) >(&TDictionary::Streamer));

    DEBUG_MSG("Adding wrapper for int TDictionary::DeclFileLine() (" __HERE__ ")");
    // signature to use in the veto list: int TDictionary::DeclFileLine()
    // defined in /home/pgras/.julia/conda/3/include/TDictionary.h:224:4
    module_.method("TDictionary!DeclFileLine", static_cast<int (*)() >(&TDictionary::DeclFileLine));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TDictionary>> type_;
};
std::shared_ptr<Wrapper> newJlTDictionary(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTDictionary(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TClass> : std::false_type { };
  template<> struct DefaultConstructible<TClass> : std::false_type { };
template<> struct SuperType<TClass> { typedef TDictionary type; };
}

// Class generating the wrapper for type TClass
// signature to use in the veto file: TClass
struct JlTClass: public Wrapper {

  JlTClass(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TClass (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TClass.h:81:7
    jlcxx::TypeWrapper<TClass>  t = jlModule.add_type<TClass>("TClass",
      jlcxx::julia_base_type<TDictionary>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TClass>>(new jlcxx::TypeWrapper<TClass>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TClass>> type_;
};
std::shared_ptr<Wrapper> newJlTClass(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTClass(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<TBuffer> : std::false_type { };
  template<> struct DefaultConstructible<TBuffer> : std::false_type { };
template<> struct SuperType<TBuffer> { typedef TObject type; };
}

// Class generating the wrapper for type TBuffer
// signature to use in the veto file: TBuffer
struct JlTBuffer: public Wrapper {

  JlTBuffer(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type TBuffer (" __HERE__ ")");
    // defined in /home/pgras/.julia/conda/3/include/TBuffer.h:43:7
    jlcxx::TypeWrapper<TBuffer>  t = jlModule.add_type<TBuffer>("TBuffer",
      jlcxx::julia_base_type<TObject>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<TBuffer>>(new jlcxx::TypeWrapper<TBuffer>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<TBuffer>> type_;
};
std::shared_ptr<Wrapper> newJlTBuffer(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlTBuffer(module));
}
